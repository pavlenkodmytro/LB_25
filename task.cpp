#include <iostream> // Наш інструмент для малювання символами в консолі
#include <vector>   // Хоча можна і звичайний масив, вектор гнучкіший (але тут юзаємо масив)

// --- Базове Креслення для всіх Дерев ---
// Це як загальне поняття "дерево", саме по собі абстрактне.
class Tree {
public:
    // "Правило хорошого тону №1" для баз поліморфізму: ВІРТУАЛЬНИЙ деструктор!
    // Це потрібно, щоб при видаленні дерева через вказівник на Tree,
    // правильно викликався деструктор конкретного типу дерева (Дуб, Ялина...).
    // Тут він порожній, бо нам особливо прибирати нічого, але він МАЄ бути віртуальним.
    virtual ~Tree() {
        // std::cout << "Tree destructor called (base)\n"; // Можна додати для дебагу
    }

    // "Що вміє кожне дерево?" - Малюватися!
    // Це ЧИСТО віртуальний метод ( "= 0" ). Це означає:
    // 1. Сам клас Tree не знає, як малювати (він абстрактний).
    // 2. КОЖЕН нащадок (конкретний тип дерева) ЗОБОВ'ЯЗАНИЙ реалізувати цей метод.
    // virtual - ключове слово для поліморфізму!
    // const - обіцянка, що малювання не змінює саме дерево.
    virtual void draw() const = 0;
}; // Кінець креслення базового дерева

// --- Креслення для Першого Типу Дерева (назвемо його "Ялинка") ---
// Спадкуємо всі властивості від базового Tree (public означає "відкрито спадкуємо")
class SpruceTree : public Tree {
public:
    // Перевизначаємо (override) метод малювання СПЕЦІАЛЬНО для Ялинки
    // override - допомагає компілятору перевірити, що ми правильно перевизначаємо віртуальний метод
    void draw() const override {
        std::cout << "Drawing 1 (Spruce):\n"; // Заголовок
        std::cout << "   /\\\n";             // Малюємо верхівку
        std::cout << "  //\\\\\n";            // Малюємо гілки
        // Додаткові рівні для краси :)
        // std::cout << " //////\\\\\n";
        // std::cout << "    ##\n";         // Стовбур
    }

    // Деструктор для Ялинки (викликається автоматично ПІСЛЯ базового) протилежність конструктору. Це теж спеціальна функція, яка викликається автоматично, коли об'єкт знищується (перестає існувати). Його головна робота - прибрати за об'єктом перед тим, як він зникне назавжди.
    ~SpruceTree() {
        // std::cout << "SpruceTree destructor called\n"; // Для дебагу
    }
};

// --- Креслення для Другого Типу Дерева (назвемо його "Сосна") ---
class PineTree : public Tree {
public:
    // Своя версія малювання для Сосни
    void draw() const override {
        std::cout << "Drawing 2 (Pine):\n";
        std::cout << "   /\\\n";
        std::cout << "  /**\\\n"; // Гілочки з зірочками :)
        // std::cout << " /****\\\n";
        // std::cout << "   ###\n";
    }

    ~PineTree() {
        // std::cout << "PineTree destructor called\n"; // Для дебагу
    }
};

// --- Креслення для Третього Типу Дерева (назвемо його "Дуб"? Хоча схоже на ялинку з плюсами) ---
class OakTree : public Tree {
public:
    // І ще одна унікальна версія малювання
    void draw() const override {
        std::cout << "Drawing 3 (Oak?):\n";
        std::cout << "   /\\\n";
        std::cout << "  /++\\\n"; // Гілки з плюсиками
        // std::cout << " /++++\\\n";
        // std::cout << "  ####\n";
    }
     ~OakTree() {
        // std::cout << "OakTree destructor called\n"; // Для дебагу
    }
};

// --- Головний Садівник (функція main) ---
int main() {
    // Створюємо "розсадник" - масив, де будуть жити вказівники на наші дерева.
    // Тип вказівників - Tree*, тобто вказівник на БАЗОВИЙ клас.
    // Це ключ до поліморфізму! Ми можемо тут зберігати адреси будь-яких нащадків Tree.
    const int forestSize = 3; // Кількість дерев у нашому лісі
    Tree* forest[forestSize]; // Оголошуємо масив з 3 вказівників на Tree

    std::cout << "Planting trees...\n" << std::endl;

    // --- Садимо дерева! ---
    // Створюємо об'єкти КОНКРЕТНИХ типів дерев (Ялинка, Сосна, Дуб) у динамічній пам'яті (купі) за допомогою `new`.
    // `new` повертає адресу створеного об'єкта.
    // Ми зберігаємо ці адреси в нашому масиві `forest`.
    // Хоча об'єкти різні (SpruceTree, PineTree, OakTree), ми можемо зберігати їх адреси як Tree*, бо вони всі є нащадками Tree.
    forest[0] = new SpruceTree(); // Садимо Ялинку на перше місце
    forest[1] = new PineTree();   // Садимо Сосну на друге місце
    forest[2] = new OakTree();    // Садимо Дуб на третє місце

    std::cout << "Drawing the forest:\n" << std::endl;

    // --- Влаштовуємо Арт-Виставку Дерев! ---
    // Проходимо по нашому "розсаднику" (масиву вказівників)
    for (int i = 0; i < forestSize; ++i) {
        std::cout << "Tree #" << i + 1 << ":" << std::endl;
        // Через вказівник `forest[i]` викликаємо метод `draw()`.
        // МАГІЯ ПОЛІМОРФІЗМУ: хоча тип вказівника `Tree*`, C++ подивиться,
        // який РЕАЛЬНИЙ об'єкт лежить за цією адресою (Ялинка? Сосна? Дуб?),
        // і викличе ПРАВИЛЬНУ версію методу `draw()` саме для цього типу дерева!
        // Це можливо завдяки ключовому слову `virtual` у базовому класі.
        forest[i]->draw();
        std::cout << "--------------------\n" << std::endl; // Роздільник для краси
    }

    // --- Дуже Важливе Прибирання! ---
    // Все, що створили за допомогою `new`, треба потім видалити за допомогою `delete`.
    // Інакше пам'ять "витече" (memory leak).
    std::cout << "Cleaning up the forest...\n";
    for (int i = 0; i < forestSize; ++i) {
        // Видаляємо об'єкт, на який вказує `forest[i]`.
        // Завдяки ВІРТУАЛЬНОМУ деструктору в класі Tree, буде викликано
        // правильний деструктор (спочатку OakTree/PineTree/SpruceTree, а потім Tree).
        delete forest[i];
        forest[i] = nullptr; // Хороша практика - зануляти вказівник після видалення
    }
     std::cout << "Done cleaning.\n";


    return 0; // Кінець шоу!
}
